### 一. 从 `Reference Type` (引用类型)开始：

`Reference Type` ：引用类型。在 [ES5 文档标准](https://es5.github.io/#x15.1)中，将`Reference` 描述为 `a resolved name binding`

[颜大的 ES5 译本](http://yanhaijing.com/es5/#80) 中，译为已解决的命名绑定，这样还是不好理解，我们需要再把中文翻译一下。

1.  `resolved` 翻译为 `已完成`

2.  `name binding` 翻译为 `命名绑定` 没有任何问题，如果有后端语言经验的同学可能更好理解。

那我们再解释下命名绑定：绑定是有双方的，把 `命名` ，也就是 `我们取的名字` ，要绑定在 `某个东西` 上面，换言之，就是用 `名字` 来描述了一个什么 `东西` 。

#### 1.为什么需要用一个名字来描述，它没有自己本身的名字吗?

举个例子:
现在我们有一个对象：`time` ，然后他有三个属性:

```javascript
 time () {
 	 second: 32,
   minute: 12,
 	 hour: 10,
 }
```

#### 2.这个对象是存在什么地方的？

我们定义完成后，它必须存在于某一个地方，才能在后面的代码中获取到它。

存在哪由 `time` 本身的特性来决定，因为它是一个对象，内部的属性是可以添加也可以减少的，换言之，**它的大小并不固定**。所以我们把它存在了 **`堆`** 里面。

那**如果它的大小固定**呢？例如 `JavaScript` 中的 6 种基本类型的值 ：`null`，`undefined`，`Boolean`，`Number` ，`String` ， `Symbol`，既然大小固定，我们就可以放在 **`栈`** 里面。

<br/>

#### 3.堆栈是什么？为什么不同类型的数据要分开放呢？

- `栈`：程序运行时系统分配的一小块内存，大小在编译期时由编译器参数决定。
- `堆`：可以理解为当前可以使用的空闲内存，其大小是需要代码编写的人员自己去申请和释放。（在 JS 中，V8 下有自动垃圾回收机制不需要我们自己操作）
  [这里只做简单解释，有需要可以自行 Google 更多信息]

<br/>

#### 4.引用类型存在堆中，和例子有什么关系？

Okay。如果你已经理解了我们的 `time` 是存在堆中的，那就很好理解了。现在我要用到 `time` 里面 `second`属性的值， 我们都知道用 `time.second` 就可以拿到，但是为什么 `time.second` 或者 `time[’second’]` 就可以访问到 `second` 属性的值呢？

看起来这个问题很蠢是不是，哈哈，但是仔细想想，按理来说：这个值是在内存里面的一小块上面，那我们需要找到这一块内存，才能取到这个值啊。

现在就很好理解了。那其实 `time.second` 或者 `time[’second’]` 他们是和内存里面的真正存放 `second` 的值那个内存位置 是绑定在一起的。只要你用到了 `time.second` 或者 `time[’second’]`，那编译器就找到，哦，这就是存在`xxxxx` 地址里面的值也就是 `32`。

### 二. `Reference Type` 和 `this` 有什么关系？

`this` 在 `Javascript` 中一直是一个初学者难以理解的点，甚至写了 2 年的项目也没搞明白为什么 `this` 有这样那样的不同。

这里我们不从使用的场景上来看 `this` 的指向，还是回归到本源。

站在编译器的角度，是怎么样去理解 `this` 指向呢？因为`this` 的指向的判断，常常发生于**函数的调用中**,那我们就来看看[ES5 文档标准](https://es5.github.io/#x15.1)中的 `11.2.3 Function Calls` (函数调用)。

一共分为 8 个步骤：

```javascript

1. Let ref be the result of evaluating MemberExpression.

2. Let func be GetValue(ref).

3. Let argList be the result of evaluating Arguments, producing an internal list of argument values (see 11.2.4).

4. If Type(func) is not Object, throw a TypeError exception.

5. If IsCallable(func) is false, throw a TypeError exception.

6. If Type(ref) is Reference, then

    a.If IsPropertyReference(ref) is true, then
    i.Let thisValue be GetBase(ref).

    b. Else, the base of ref is an Environment Record
    i.Let thisValue be the result of calling the Implicit This Value concrete method of GetBase(ref).

7. Else, Type(ref) is not Reference.

    a.Let thisValue be undefined.

8. Return the result of calling the [[Call]] internal method on func, providing thisValue as the this value and providing the list argList as the argument values.
```

我就不翻译了，因为就算翻译出来你可能也读得很累，那么我们用图来看下这个流程会更加直观。

![](http://ww1.sinaimg.cn/large/88b26e1cly1fyc4xelu4yj20tv18vgs2.jpg)

我已经把最关键的几个步骤都标红了，如果在第三步返回的 `func` 无法通过 `5` 的判断的话，根本就没有讨论 `this` 指向的必要。

所以我们重点看：这个里面最关键的点，第 `2` , `6` , `7` 步骤：

- 第 `2` 步：**计算 `MemberExpression` 的值并且赋值给 `Ref`**:
  也就是计算 `()` 左边的内容的结果，并赋值给 `Ref`。换句话说: `Ref` 就是对于 `()` 左边的内容进行计算之后的引用。
  <br>

- 第 `6` 步：**判断 ref 是否为 Reference 类型**:
  这个没什么好说的。
  <br>

- 第 `7` 步：**判断 ref 是否是属性引用类型**:
  官方解释：
  通过执行`IsPropertyReference(V)`来判断的，如果基值是个对象或 `HasPrimitiveBase(V)` 是 true，那么返回 true；否则返回 false。
  `HasPrimitiveBase(V)`：如果基值是 Boolean, String, Number，那么返回 true。
  换成大白话，**取决于`Ref`这个引用是基于谁的？** 如果它基于一个`对象` 或者 `Boolean`, `String`, `Number`那就返回 `true` 否则返回 `false`。

OK 看到这里，估计你也有些累，但是最关键的部分在下面。

### 三. 回过头来看 `this` 的 N 种情况

#### 1.直接调用

```javascript
let a = 'm';
function test() {
  console.log(this.a);
}
test(); // m
```

我们用刚刚所看到的 `3` 个步骤来判断下 `this`:

1. `test()` 的 `Ref` 就是 `test`引用，它关联到在内存中存储了`test()`的某一片段。
2. 判断 `test()` 是否为引用类型 => `true`
3. 判断 `Ref` 是否是属性引用类型 => `false`，它并没有定义在某个引用类型的内部。
4. 进入到图中的第九个步骤：`this = ImplicitThisValue(Ref)` ，在 `Environment Records` 下返回 `undefined` ,而在非严格模式下，浏览器会把 `this` 指向 `window`

说起来很麻烦，其实理解起来很简单。

#### 2.在对象内部调用

```javascript
function test() {
  console.log(this.a);
}
let parent = {
  a: 's',
  test: test
};
parent.test(); // s
```

1. `parent.test()` 的 `Ref` 就是 `parent.test`引用，它关联到在内存中存储了`test()`的某一片段。
2. 判断 `parent.test()` 是否为引用类型 => `true`
3. 判断 `Ref` 是否是属性引用类型 => `true`
4. 进入到图中的第八个步骤：`this = GetBase(Ref)` 那这个`test()` 方法是基于谁呢？很明显就是 `parent`,所以 `this` => `parent`

#### 3.new 方法调用

```javascript
    let a = k;
    function test() {
        console.log(this.a);
    }
    let c = new test();
    c.a = 's';
```
1. 这里的`Ref` 值参考 [es5的官方文档 11.2.2 NewExpression](https://es5.github.io/#x15.1)：**解释执行 NewExpression 的结果复制给 ref** 那在这里 `new test` 的结果就是 `Ref` 也就是这个 `new` 出来的对象，在这里我们用 `c` 接收了它。
2. 判断 `test()` 是否为引用类型 => `true`，这里的 `test()` 仍旧是一个引用类型。
3. 
